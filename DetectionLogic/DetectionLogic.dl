/* Facts - re-entrancy
 * direct_call(c:CallNum, a1:EthAddress, a2:EthAddress, p:NatNum)
 * The call number c in a given transaction constitutes a call from a contract with address a1 
 * to contract with address a2. The call involves p Ether.
 * 
 * call(c:CallNum, a1:EthAddress, a2:EthAddress, p:IntSet)
 * ibid.
 * 
 * reentrancy(c:ProgCounter, a1:EthAddress, a2:EthAddress, p:IntSet, p2:IntSet)
 * At programme counter, c, the call from contract address a1 to address a2 involved
 * a reentrant callback to the calling contract, address a1.
*/

//types
.number_type CallNum
.symbol_type EthAddress		//Ethereum address for caller and called contracts
.type NatNum = number
.type IntSet = number

.decl direct_call(c:CallNum, a1:EthAddress, a2:EthAddress, p:NatNum)
.input direct_call

.decl call(c:CallNum, a1:EthAddress, a2:EthAddress, p:IntSet)

.decl reentrancy(c:CallNum, a1:EthAddress, a2:EthAddress, p:IntSet, p2:IntSet)
.output reentrancy

call(C, A1, A2, P) :- direct_call(C, A1, A2, P); direct_call(C, A1, A3, P), call(C2, A3, A2, P2).

reentrancy(2, A1, A2, P, P2) :- call(2, A1, A2, P), call(1, A2, A1, P2), A1 != A2.

**************************************************************************************************

/* Facts - Locked Ether
 * call_entry(g1:gas, a1:EthAddress)
 * Contract with address a1 is called when gas value is c1
 * 
 * call_exit(g2:gas)
 * Gas value is c2 when exiting a call to a contract.
 *
 * locked_ether(a1:EthAddress, g1:gas)
 * In the calling of contract with address a1 and gas value g1
 * an instance of Locked Ether has been detected
*/

//types
.number_type gas
.symbol_type EthAddress		//Ethereum address for caller and called contracts

.decl call_entry(g1:gas, a1:EthAddress)
.input call_entry

.decl call_exit(g2:gas)
.input call_exit

.decl locked_ether(a1:EthAddress, g1:gas)
.output locked_ether

locked_ether(A1, G1) :- call_entry(G1, A1), call_exit(G2), G1+1=G2.

